<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>柯里化</title>
</head>

<body>
  <script>
    // 调用形式
    function add(a, b, c) {
      console.log(this)
      return a + b + c;
    }
    var newAdd = Curry(add);
    newAdd(1)(2)(3);
    // 或者
    newAdd(1, 2)(3);

    // 我的仿写 - 
    // function Curry(fun){
    //   return function(a){
    //     fun(1);
    //     return function(b){
    //       fun(2);
    //       return function(c){
    //         fun(3);

    //       }
    //     }
    //   }
    // }

    // 一步一步来，一笔画不出一个“王”字，就先画一个“一”嘛
    // 固定参数的柯里化
    /* 也就是Curry里除了add还传了n个参数，那newAdd里就要传最终应该有的参数个数 - n个 */
    function Curry(fn) {
      var args1 = Array.prototype.slice.call(arguments, 1); //从第二个参数截取，避开fn
      return function () {
        var args2 = Array.prototype.slice.call(arguments); //转成数组
        return fn.apply(this, args1.concat(args2));
      }
    }
    var newAdd1 = Curry(add, 2);
    var newAdd2 = Curry(obj.add, 2);
    console.log(newAdd1(2, 3));
    console.log(newAdd2(2, 2));
    // 以上，从curry中获取除了fn的所有参数，利用数组slice方法，截取除第一个以外的所有参数。（这里不能用shift，因为shift改变原数组。slice不改变原数组）
    // 然后curry的返回值还是一个函数，这个函数也就是后期示例中newAdd1调用的那个函数，这个函数内部的所有参数都是用来add的参数，需要全部获取。同时为了后期的参数合并，这里也利用slice方法进行了转化、
    // 最后调用fn，并传参，参数是两次arguments组成的数组。至于使用apply，一方面可以改变fn内部this指向。（否则fn调用的时候this指向window）另外主要是为了传参用我们刚才合成的数组。只有apply有这个功能让我们把所有参数合成一个数组全部穿进去。
    

  </script>
</body>

</html>