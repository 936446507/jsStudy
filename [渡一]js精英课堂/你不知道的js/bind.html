<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>bind</title>
</head>

<body>
  <ul>
    <li>
      bind作用：改变函数内部this指向
    </li>
    <li>与call或apply的区别：call和apply是直接调用函数，bind则是返回一个新的函数，新函数调用执行函数里的内容，只不过this发生改变。可以理解成，bind就是一个方法过滤器，把函数内部的内容拿出来给了新函数，并把this改变。然后把新函数再返回出来。</li>
    <li>被bind改变过一次this指向的函数，其this不能再用call和apply甚至bind改变了</li>
    <li>那被bind过的函数，再次执行new还会改变this指针吗？毕竟new构造函数也是改变this的一种方法啊！测试结果是，new可改变被bind绑定过的函数的this指向。其指向按照new的原则走</li>

    <li>bind独特特性：函数柯里化</li>
    <li>bind的第一个参数会被当做this指针的对象传进去。第二个乃至第n个参数，就是调用bind的函数要接受的参数了。</li>
    <li>bind实现柯里化的特点也就是，假如一个函数需要5个参数，我第一次使用bind调用函数时除了this指针对象以外，还传入了2个参数。那么调用bind返回的函数体再次被调用时，可以再传入后3个参数。</li>

  </ul>
  <script>
    var str = 'window';
    var obj = {
      str: 'obj'
    }
    var test = {
      str: 'test'
    }


    function testCall() {
      console.log(this.str);
    }

    function testBind() {
      console.log(this.str);
    }


    var callResult = testCall.call(obj);
    var bindResult = testBind.bind(test);
    /* 控制台中只打印出了testCall执行的结果。testBind并没有被执行。看bind的颜色都是不对的 */
    console.log(callResult);
    console.log(bindResult)
    // 因为两个函数内部都没有写返回值，所以callResult返回undefined
    // 但是因为bind的原理机制，函数调用bind是返回一个新函数。而这个新函数的函数体依旧是调用bind的函数，即testBind。但是函数体内部的this指向已经改变，只是我们看不出来。
    bindResult()
    // 因为此时bindResult拿到的就是新的函数体，所以他可以被调用。我们调用他相当于调用testBind的双胞胎妹妹。执行结果也就是输出this.str，此时this被bind绑定给test了，所以str也就是‘test’

    /* 使用bind转换过后还不满意，想用call或apply再次转换this试试 */
    bindResult.call(obj);
    // 结果发现，并没有卵用，this依旧指向test。这就是被bind调用后的函数，内部this不能再被call或apply改变了。

    /* 使用new测试 */
    var myNew = {
      str1: 'new构造函数的影响'
    }

    function forNewBind() {
      this.str2 = 'new构造函数准备的'
      console.log(this.str1,this.str2);
    }
    var forNew = forNewBind.bind(myNew);
    console.log(forNew);
    forNew();//this指向myNew，正常bind作用
    console.log(myNew);
    var newFornew = new forNew();//this指向new时产生的this对象，str1为undefine，str2为自身属性被输出
    console.log(newFornew)
    console.log(myNew)

    // 说明，new能继续改变bind过后的函数的this指向。这里可以打断点查看scope就知道了，this指向改变的很明显。


    // bind实现柯里化
    var bindThis = {
      name: 'xing.org1^',
      age: 18
    }

    function bindCurry(a, b, c, d, e) {
      console.log('this指针', this);
      console.log(a, b, c, d, e);
    }

    /* 柯里化传参 */
    var newBindRst = bindCurry.bind(bindThis, '我是对应参数a的', '我是对应参数b的');

    //调用bind的返回结果，再次传入剩下的参数
    newBindRst('我是对应参数c的', '我是对应参数d的', '我是对应参数e的');

    /* bind仿写 */
    Function.prototype.xingorgBind = function (params) {


    }
  </script>
</body>

</html>